var store = [{
        "title": "프로세스(Process)와 스레드(Thread)",
        "excerpt":"1. Program     어떤 작업을 위해 실행할 수 있는 파일 (An executable file)   2. Process     실행중인 프로그램 (Computer program in execution)   프로세스가 동작한다는 것은 프로세스의 특정 스레드가 실행중이라는 것.    그 스레드는 프로세스가 가진 데이터를 참조함.     구성            Register: 명령, 주소 등을 가지고 있는 부분       Counter: 프로그램 안에서 어느 위치를 실행시키고 있는 지를 가르키는 부분       Stack: 프로세스의 메모리 공간을 관리하기 위한 알고리즘중 하나. 호출된 함수, 지역 변수 등의 임시 데이터       Heap: 동적으로 생성된 데이터 영역(ex. new Object(), malloc(), …)                    스택보다 할당할 수 있는 메모리 공간이 많다는 것이 장점이지만 포인터로 메모리 영역을 접근해야 하기 때문에 다른 자료구조에 비해서 데이터를 읽고 쓰는게 느리다.                       Code: 프로세스가 실행할 코드와 매크로 상수가 기계어의 형태로 저장된 공간       Data: 전역변수 또는 static 변수 등이 저장된 공간.               3. Thread     프로세스 내에서 실행되는 작업 흐름의 단위. (The unit of execution within a process)       4. Process vs Thread                          Process       Thread                       개념       실행 중인 프로그램       프로세스의 실행 단위                 종료       시간 소요 ↑       시간 소요 ↓                 생성       시간 소요 ↑       시간 소요 ↓                 Context switching       시간 소요 ↑       시간 소요 ↓                 커뮤니케이션       효율성 ↓       효율성 ↑                 리소스       소비 ↑       소비 ↓                 자원 공유       독립, 격리       공유(Heap, Data, Code)                 전환       운영 체제의 인터페이스를 사용       운영 체제를 호출하지 않음(커널 중단 X)           5. Multiprocessing, Multithread     CPU의 최대 활용을 위해 프로그램의 둘 이상의 부분을 동시에 실행하는 기술   6. 동시성(Concurrency) vs 병렬성(Parallelism)     동시성 - 동시에 실행되는 것 같이 보이는 것. ex)싱글 코어 + 멀티 스레드   병렬성 - 실제로 동시에 여러 작업이 처리 되는 것. ex)멀티 코어 + 멀티 스레드   7. Multitasking     task를 번갈아가며 수행하는 것   프로세스의 응답 시간을 최소화 시키는데 목적   마치 동시에 여러 프로그램이 실행되는듯 느끼게함   하나의 프로세스가 동시에 여러 작업을 수행하지는 못함   8. Context Switching     CPU를 한 프로세스 또는 스레드에서 다른 프로세스 또는 스레드로 전환하는 것   프로세스 제어 블록(PCB)에서 현재 실행중인 프로세스의 상태(Context)를 먼저 저장하고, 다음 프로세스를 동작시켜 작업을 처리한 후에 이전에 저장된 프로세스의 상태를 다시 복구하여 재개   이를 통해 여러 프로세스가 단일 CPU를 공유   9. Multiprocessing     두개 이상의 프로세서나 코어가 작업을 병렬처리하는 것   각 프로세스가 메모리 영역을 따로 가지기 때문에 비효율이 발생   10. Multithread     하나의 프로세스가 다수의 작업을 각각의 스레드를 이용하여 동시에 작동 시킬 수 있다   공유 메모리(Code, Data, Heap)를 가지기 때문에 서로간의 자원 공유가 가능하여 프로세스간 통신과 같은 과정을 거치지 않아 효율적이다   같은 데이터를 공유하기 때문에 데이터 동기화에 신경 써야 한다. 한 프로세스 안의 스레드가  문제가 생기면 같은 프로세스안의 다른 스레드도 문제가 발생하게 된다         참고 자료 :     https://www.youtube.com/watch?v=QmtYKZC0lMU   https://www.youtube.com/watch?v=RrfASw-jfZ4&amp;t=28s   https://www.youtube.com/watch?v=dzfij2nZbRw   https://mangkyu.tistory.com/92  ","categories": ["Computer Science"],
        "tags": ["Process","Thread"],
        "url": "/computer-science/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-process-%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C-thread",
        "teaser": null
      },{
        "title": "JPA 영속성 컨텍스트 정리",
        "excerpt":"JPA에서 가장 중요한 2가지     객체와 관계형 데이터베이스 매핑 (Object Relational Mapping)   영속성 컨텍스트   영속성 컨텍스트     엔티티를 영구 저장하는 환경   논리적 개념   엔티티 매니저를 통해서 영속성 컨텍스트에 접근  EntityManager.persist(entity);   엔티티의 생명주기          비영속(new/transition) : 영속성 컨텍스트와 관계가 없는 새로운 상태         //객체를 생성한 상태   Member member = new Member();   member.setId(\"member1\");   member.setUserId(\"회원1\");                       영속(managed) : 영속성 컨텍스트에 관리되는 상태         ...   EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"~~\");   EntityManager em = emf.createEntityManager():   em.getTransaction().begin();        //객체를 저장한 상태(영속)   em.persist(member);                  바로 DB에 저장되는 것은 아님. commit 시점에 db로 쿼리가 전달.                       준영속(detached) : 영속성 컨텍스트에 저장되었다 분리된 상태         em.detach(member);                       삭제(removed) : 객체를 삭제한 상태         em.remove(member);               영속성 컨텍스트의 이점          (1) 1차 캐시 → DB 한 트랜잭션 내에서만 공유하기 때문에 일반적인 상황에서 성능적으로 그리 큰 이점은 아니다.            (2) 영속 엔티티의 동일성(identity) 보장         ...   Member findMember1 = em.find(Member.class, 1L);   member findMember2 = em.find(Member.class, 1L);    //true   System.out.println(\"result = \" + (findMember1 == findMember2))          → 1차 캐시로 반복 가능한 읽기(Repeatable Read) 등급의 트랜잭션 격리 수준을, 데이터베이스가 아닌 애플리션 차원에서 제공            (3) 트랜잭션을 지원하는 쓰기 지연 (transactional wirte-behind)         ...   transaction().begin(); // 트랜잭션 시작          em.persist(memberA);   em.persist(memberB)   // 아직 Insert SQL을 DB로 보내지 않음          transation.commit(); // 트랜잭션 커밋   // 커밋하는 순간 DB로 Insert SQL을 보냄                       (4) 변경 감지 (Dirty Checking)         ...   transaction.begin(); // 트랜잭션 시작        // 영속성 엔티티 조회   Member memberA = em.find(Member.class, 1L);        memberA.setUsername(\"newName\");   memberA.setAge(10);        // Dirty Checking을 통해 커밋시에 Update SQL이 나감.        transaction.commit; // 트랜잭션 커밋                  영속성 컨텍스트의 커밋 과정:                    ① flush()           ② 엔티티와 스냅샷(영속 상태가 된 최초 시점) 비교           ③ 변경된 부분이 있다면 Update Sql을 쓰기 지연 SQL 저장소에 생성           ④ flush()           ⑤ Commit                                   플러시(flush)                    영속성 컨텍스트의 변경 내용을 데이터베이스에 반영. 트랜잭션 커밋이 발생하면 자동으로 발생.           플러시 발생 → 변경 감지 → 수정된 엔티티 쓰기지연 SQL 저장소에 등록 → 쓰기지연 SQL 저장소의 쿼리를 DB에 전송           영속성 컨텍스트를 비우지 않음.                                  (5) 지연 로딩 (Lazy Loading)          ※ [인프런] 자바 ORM 표준 JPA 프로그래밍 - 김영한   ","categories": ["Spring Data"],
        "tags": ["JPA","영속성컨텍스트"],
        "url": "/spring-data/jpa-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%A0%95%EB%A6%AC",
        "teaser": null
      },{
        "title": "스택(Stack)과 큐(Queue)",
        "excerpt":"Abstract Data Type &amp; Data Structure           ADT(Abstract Data Type) : 추상 자료형. 개념적으로 어떤 동작이 있는지만 정의하고 구현에 대해서는 다루지 않음            DS(Data Structure) : 자료구조. ADT에서 정의된 동작을 실제로 구현한 것           Stack vs Queue      스택(Stack) : LIFO(Last In First Out) 형태로 데이터를 저장하는 구조. 나중에 들어간 것이 먼저 나옴.            주요 동작:                    Push : 스택에 아이템을 넣음           Pop : 스택에서 아이템을 꺼냄           Peek : 스택 최상단의 아이템을 알아냄                       사용 사례 :                    Stack Memory (영상)           Stack Frame                       관련 에러 및 해결                    StackOverflowError : 스택 메모리 공간을 다 썼을 때 발생           대개 재귀 함수(recursive function)에서 탈출하지 못해서 발생           탈출 조건을 잘 확인하여 해결                                  큐(Queue): FIFO(Fisrt In First Out) 형태로 데이터를 저장하는 구조. 먼저 들어간 것이 먼저 나옴.            주요 동작 :                    Enqueue : 큐에 아이템을 넣음           Dequeue : 큐에서 아이템을 꺼냄           Peek : 꺼낼 아이템을 알아냄                       사용 사례 :                    Producer/Consumer Architecture  (영상)                       기술 문서에서 Queue :                    항상 FIFO를 의미 하지는 않음. (Ex.Priority Queue)                       관련 에러 및 해결                    OutOfMemoryError : Java의 힙(heap) 메모리를 다 썼을 때 발생           큐에 데이터가 계속 쌓이기만 한 경우 발생           큐 사이즈를 고정하여 해결                              큐가 다 찼다면? :                                    예외 던지기                   특별한 값(null or false)을 반환                   성공할 때까지 스레드 블락(대기)                   제한된 시간동안 블락하고 안되면 제외(Time out)    ex) LinkedBlockingQueue                                                                                     참고 자료 :      https://www.youtube.com/watch?v=-2YpvLCT5F8   ","categories": ["Data Structure"],
        "tags": ["Stack","Queue"],
        "url": "/data-structure/%EC%8A%A4%ED%83%9D-stack-%EA%B3%BC-%ED%81%90-queue",
        "teaser": null
      },{
        "title": "Linked list",
        "excerpt":"   컴퓨터에 자료를 저장하는 구조의 한 종류로, 엘리먼트와 엘리먼트 간의 연결(link)을 이용해서 리스트를 구현한 것이다.   데이터를 저장한 노드에 다음 노드의 주소를 가지고 있는 구조.   일렬로 연결된 데이터를 저장할 때 사용   배열과 차이            배열 : 물리적으로 한 곳에 정해져 있음. 한번 정해진 크기는 고정.       링크드 리스트 : 길이가 정해져있지 않은 데이터의 연결된 집합           길이가 정해지지 않은 데이터를 핸들링 할 때 유리        ※ 사실 오늘날 어플리케이션 프로그램에서 연결 리스트의 사용 빈도는 많이 줄었습니다. 그 이유는 하드웨어 발전이랑 관련이 있습니다. CPU에 들어가는 캐시 메모리는 연속된 메모리에 접근할 때 굉장히 빠른 속도를 보장합니다. 따라서 이 부분에 있어서 연결 리스트보다는 배열이 더 유리합니다. 그래서 연결 리스트보다는 다른 언어의 다른 자료구조가 더 활용되고 있는데 그 중 하나가 C#언어의 리스트입니다. 다른 말로 동적 배열입니다. 배열로 잡아두고 배열 크기가 커지면 크기만 바뀌는 개념입니다.  ㄴ 출처: https://bite-sized-learning.tistory.com/239       단/양방향            단방향(Singly Linked List) : 다음 노드의 주소만 가지고 있는 형태       양방향(Doubly Linked List) : 이전 노드의 주소도 추가로 가지고 있어 양방향 이동이 가능(메모리 사용량 ↑)           자바로 Linked List 구현   https://github.com/warscodev/Algorithm_Study/tree/master/src/dataStructure/linkedList   Class Node{   int data;   Node next = null;      Node(int d){     this.data = d;   }      void append(int d){     Node end = new Node(d);     Node n = this;          while(n.next != null){       n = n.next;     }     n.next = end;   }      void delete(int d){     Node n = this;     while(n.next != null){       if(n.next.data == d){         n.next = n.next.next;       }else{         n = n.next;       }     }   }      void retrieve(){     Node n = this;          while(n.next != null){       System.out.print(n.data + \" = \");       n = n.next;     }     // 마지막 데이터 출력     System.out.ptrinln(n.data);   } }   LeetCode 문제   Intersection of Two Linked Lists :     https://leetcode.com/problems/intersection-of-two-linked-lists/       참고자료 :      https://opentutorials.org/module/1335/8857   https://www.youtube.com/user/damazzang/videos   ","categories": ["Data Structure"],
        "tags": ["Linked List"],
        "url": "/data-structure/linked-list",
        "teaser": null
      },{
        "title": "IntelliJ에서 Thymeleaf 실시간 변경(Live reload) 적용하기",
        "excerpt":"서버를 재구동 하지 않고 Thymeleaf의 변경사항을 실시간으로 적용하는 방법을 알아보자.       1. application.yml 파일 thymeleaf 설정   spring     thymeleaf:         cache: false       2. 인텔리제이     1. Run → Edit Configurations (구성 편집)          2. On ‘Update’ action(‘Update’ 작업 시) &amp; On frame deactivation(프레임 비활성화 시) → Update classes and resources(클래스 및 리소스 업데이트)                  정상적으로 적용된 모습      ","categories": ["Template Engine"],
        "tags": ["Thymeleaf","IntelliJ"],
        "url": "/template-engine/intellij%EC%97%90%EC%84%9C-thymeleaf-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%B3%80%EA%B2%BD-live-reload-%EC%A0%81%EC%9A%A9",
        "teaser": null
      },{
        "title": "AD(Active Directory)",
        "excerpt":"중앙 서버에 공통된 데이터베이스를 생성하여 각 서버와 클라이언트가 해당 데이터베이스를 공유하여 Object를 검색하고,   중앙에서 사용자 인증 및 권한 부여 처리가 가능하도록 처리해주는 Windows 기반의 중앙 집중 관리 서비스.   일반적인 RDBMS와는 다른 파일 타입의 데이터베이스이다.   구성   1. 도메인(Domain)   관리를 위한 기본 단위. 동일한 데이터베이스를 공유하는 사용자와 디바이스가 이에 해당된다.   2. 트리(Tree), 포레스트(Forest)   트리는 도메인의 결합, 포레스트는 트리의 결합니다.       ","categories": ["Server"],
        "tags": ["AD"],
        "url": "/server/ad-active-directory",
        "teaser": null
      },{
        "title": "[Git] 2. Git 최초 설정 및 프로젝트 세팅",
        "excerpt":"    1. Git 전역 설정   1.1 사용자 이름 및 이메일 주소 설정           터미널에서 아래 명령어 실행         git config --global user.name \"(본인 이름)\"        git config --global user.email \"(본인 이메일)\"                아래 명령어로 확인 가능         git config --global user.name        git config --global user.email                  1.2. 기본 브랜치명 설정           아래 명령어로 기본 브랜치명을 ‘main’으로 설정         git config --global init.defaultBranch main                아래 명령어로 기본 브랜치명 확인         git config --get init.defaultBranch                      2. 프로젝트 생성 &amp; Git 관리 시작   2.1. Git 저장소 생성           프로젝트 경로 아래에서 아래 명령어 입력         git init                         폴더에 숨김모드로 .git 폴더 생성 확인              맥에서 숨김 파일 보기: command + shift + .           2.2. Git 저장소 상태           프로젝트에 아래 파일 생성                   프로젝트 경로 아래에서 아래 명령어 입력         git status                 ","categories": ["VCS"],
        "tags": ["Git"],
        "url": "/vcs/git-%EC%B5%9C%EC%B4%88-%EC%84%A4%EC%A0%95-%EB%B0%8F-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%84%B8%ED%8C%85",
        "teaser": null
      },{
        "title": "[Git] 1. 설치 및 세팅",
        "excerpt":"   💡 Git, Git Bash, SourceTree 설치 및 세팅             1. 다운로드와 설치   1.1. Git과 Git Bash설치     https://git-scm.com/ 에서 다운로드        Git Bash도 함께 설치할 것!                   설치 후 Git Bash에서 테스트         git --version                       아래 명령어로 OS별 개행문자 통일 [참고]         git config --global core.autocrlf true                      1.2. SourceTree 설치      https://www.sourcetreeapp.com/   BitBucket, Mercurial 건너 뛰기       1.3. 인텔리제이 터미널 기본설정을 Git Bash로 변경      Setting → Tools → Terminal        Shell path에 아래 경로 입력         \"C:\\Program Files\\Git\\bin\\sh.exe(shell이 설치된 경로)\" -login -i                       인텔리제이 재시작 후 터미널 확인             ","categories": ["VCS"],
        "tags": ["Git"],
        "url": "/vcs/git-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EC%84%B8%ED%8C%85",
        "teaser": null
      },{
        "title": "동기화와(Synchronization)와 교착상태(Deadlock)",
        "excerpt":"   💡 동기화와 데드락은 공유 자원을 사용하는 프로세스나 스레드 간의 상호 작용에서 중요한 개념들이다. 동기화를 통해 여러 프로세스나 스레드가 공유 자원을 안전하게 접근하도록 도와주지만, 잘못된 동기화는 데드락을 일으킬 수 있다.    📌동기화 (Synchronization)     동기화란?   여러 프로세스나 스레드가 공유 자원에 동시에 접근할 때 발생할 수 있는 문제를 방지하기 위해 그들 사이의 실행 순서를 조절하는 것을 말한다.   동기화의 필요성      여러 프로세스나 스레드가 공유 자원에 동시에 접근할 때 데이터의 일관성을 유지하기 위해 필요하다.   동시성 제어 없이 공유 자원을 동시에 변경하면 예기치 않은 결과나 오류가 발생할 수 있다.   동기화 기법   1. 임계 구역 (Critical Section)      설명: 여러 프로세스가 동시에 접근하면 안 되는 공유 자원을 접근하는 코드 부분.   예시: 두 스레드가 동시에 은행 계좌 잔액을 변경할 때 해당 코드 부분.   2. 뮤텍스 (Mutex)      설명: 임계 구역에 하나의 스레드만 들어갈 수 있도록 보장하는 동기화 기법.   예시: 파일을 한 번에 하나의 프로세스만 쓸 수 있도록 제한하는 경우.   3. 세마포어 (Semaphore)      설명: 동시에 접근할 수 있는 스레드나 프로세스의 최대 허용 수를 제한하는 동기화 기법.   예시: 동시에 3개의 스레드만 데이터베이스에 쓸 수 있도록 제한하는 경우.   4. 모니터 (Monitor)      설명: 뮤텍스와 조건 변수를 결합하여 임계 구역을 보호하는 높은 수준의 동기화 기법.   예시: 한 스레드가 데이터를 추가하면 다른 스레드가 그 데이터를 처리하는 경우.   레이스 컨디션 (Race Condition)      설명: 두 개 이상의 스레드가 공유 자원을 동시에 변경하려고 할 때 발생하는 상황.   예시: 두 스레드가 동시에 은행 계좌 잔액을 조회하고 변경할 때 잔액이 잘못된 값으로 설정되는 경우.   동기화는 복잡한 환경에서 여러 프로세스나 스레드가 원활하게 작동하도록 하는 중요한 개념이다. 잘못된 동기화는 시스템 성능 저하나 데이터 손실과 같은 큰 문제를 일으킬 수 있다.        📌교착상태 (Deadlock)     교착상태란?   여러 개의 프로세스나 스레드가 서로를 기다리며 무한히 대기하는 상황을 뜻한다.   교착상태의 조건   교착상태의 발생에는 다음의 4가지 필요 충분 조건이 있다   1. 상호배제 (Mutual Exclusion)      설명: 한 번에 한 프로세스만이 특정 자원을 사용할 수 있다.   예시: 프린터는 한 번에 하나의 작업만 처리할 수 있습니다. 따라서 두 개의 프로세스가 동시에 프린터를 사용하려고 시도하면 상호배제 조건이 위반된다.   2. 점유와 대기 (Hold and Wait)      설명: 프로세스가 이미 어떤 자원을 보유하고 있으면서 다른 자원을 기다릴 때 발생한다.   예시: 프로세스 A가 파일을 보유하면서 프린터를 기다리고, 프로세스 B가 그 프린터를 보유하면서 해당 파일을 기다리는 상황.   3. 비선점 (No Preemption)      설명: 자원이 한 프로세스에 의해 점유되어 있을 때, 다른 프로세스가 그 자원을 강제로 뺏어오지 못한다.   예시: 프로세스 A가 데이터베이스 연결을 사용 중일 때, 프로세스 B는 A로부터 그 연결을 강제로 가져올 수 없다.   4. 환형 대기 (Circular Wait)      설명: 각 프로세스는 순차적으로 다음 프로세스가 요청한 자원을 보유하고 있다.   예시: 프로세스 A는 메모리를 보유하면서 디스크를 기다리고, 프로세스 B는 디스크를 보유하면서 네트워크 연결을 기다리고, 프로세스 C는 네트워크 연결을 보유하면서 메모리를 기다리는 상황.   이 네 가지 조건 중 어느 하나라도 만족되지 않으면 교착상태는 발생하지 않는다.   교착상태 해결 방법   1. 예방 (Deadlock Prevention)      설명: 교착상태의 4가지 조건 중 하나 이상을 무효화시켜 교착상태가 발생하지 않도록 하는 방법   예시:            상호배제: 이 조건을 제거하기 위해 프린터와 같은 공유 자원에 대해 동시 접근을 허용하는 방식으로 디자인할 수 있습니다. 하지만, 이는 자원의 특성에 따라 불가능할 수도 있다.       점유와 대기: 프로세스가 실행되기 전에 모든 필요한 자원을 한 번에 요청하도록 하여 이 조건을 제거할 수 있다.       환형 대기: 자원에 순번을 부여하고, 프로세스가 순서대로 자원을 요청하도록 함으로써 이 조건을 제거할 수 있다.           2. 회피 (Deadlock Avoidance)      설명: 시스템의 상태를 검사하여 교착상태가 발생할 가능성이 있을 때 해당 작업을 거부하는 방법   예시:            Banker’s Algorithm: 각 프로세스가 필요로 하는 최대 자원을 미리 알려주고, 시스템은 안전한 상태를 유지하기 위해 자원 할당 여부를 결정한다.           3. 탐지 및 복구 (Deadlock Detection &amp; Recovery)      설명: 교착상태가 발생했는지 시스템을 주기적으로 확인하고, 발견될 경우 복구하는 방법   예시:            자원 할당 그래프: 주기적으로 그래프를 확인하여 사이클이 발생하는지 검사합니다. 사이클이 발견되면 교착상태가 발생한 것으로 간주한다.       복구 방법: 교착상태에 있는 프로세스를 종료하거나, 프로세스로부터 자원을 강제로 회수하여 교착상태를 해결한다.           4. 무시 (Deadlock Ignorance)      설명: 교착상태가 발생할 확률이 매우 낮다고 가정하고, 특별한 조치를 취하지 않는 방법   예시: 대부분의 운영체제는 교착상태가 발생할 확률이 낮다고 가정한다. 따라서 대부분의 경우 운영체제는 교착상태를 무시한다. 사용자는 문제가 발생할 경우 시스템을 재시작하거나 해당 프로세스를 수동으로 종료하여 문제를 해결한다.   각 방법마다 장단점이 있으므로, 시스템의 특성과 요구사항에 따라 적절한 방법을 선택해야 한다.        📌동기화와 데드락     동기화와 데드락의 관계   동기화는 여러 프로세스나 스레드가 공유 자원에 안전하게 접근할 수 있도록 도와주는 기법이다. 하지만, 동기화를 잘못 구현하면 데드락이 발생할 수 있다. 예를 들어, 두 프로세스가 서로 다른 뮤텍스를 잡고, 서로의 뮤텍스를 기다리는 상황이 발생하면 데드락이 발생한다.   동기화 기법과 데드락   1. 임계 구역 (Critical Section)      데드락 위험: 임계 구역을 보호하기 위한 동기화 메커니즘이 잘못 구현되면 데드락 위험이 있다.   2. 뮤텍스 (Mutex)      데드락 위험: 두 스레드나 프로세스가 서로의 뮤텍스를 기다리는 상황에서 데드락이 발생할 수 있다.   3. 세마포어 (Semaphore)      데드락 위험: 여러 세마포어를 사용할 때, 프로세스들이 서로 다른 순서로 세마포어를 요청하면 데드락이 발생할 수 있다.   4. 모니터 (Monitor)      데드락 위험: 모니터 내에서 여러 조건 변수를 사용하면서 잘못된 순서로 대기하게 되면 데드락이 발생할 수 있다.   동기화를 통한 데드락 해결   동기화 기법 중 하나인 뮤텍스와 세마포어를 활용하여 데드락을 예방할 수 있다. 예를 들어, 여러 뮤텍스를 사용할 때 항상 일정한 순서로 뮤텍스를 획득하도록 설계하면 환형 대기 조건을 무효화시켜 데드락을 예방할 수 있습니다.           💡 동기화와 데드락은 서로 밀접한 관계가 있으며, 동기화를 통해 시스템의 동시성을 보장하면서도 데드락을 예방하거나 회피하는 것이 중요하다.       ","categories": ["Computer Science"],
        "tags": ["Synchronization","Deadlock"],
        "url": "/computer-science/%EB%8F%99%EA%B8%B0%ED%99%94%EC%99%80-synchronization-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-deadlock",
        "teaser": null
      }]
